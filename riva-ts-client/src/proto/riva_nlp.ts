// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.29.3
// source: riva_nlp.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal";

export const protobufPackage = "nvidia.riva";

export interface ClassifyRequest {
  text: string[];
  model: ClassifyRequest_Model | undefined;
}

export interface ClassifyRequest_Model {
  modelName: string;
  languageCode: string;
}

export interface ClassifyResponse {
  results: ClassifyResponse_Result[];
}

export interface ClassifyResponse_Result {
  label: string;
  score: number;
}

export interface TokenClassifyRequest {
  text: string[];
  model: TokenClassifyRequest_Model | undefined;
}

export interface TokenClassifyRequest_Model {
  modelName: string;
  languageCode: string;
}

export interface TokenClassifyResponse {
  results: TokenClassifyResponse_Result[];
}

export interface TokenClassifyResponse_Token {
  text: string;
  label: string;
  score: number;
  start: number;
  end: number;
}

export interface TokenClassifyResponse_Result {
  tokens: TokenClassifyResponse_Token[];
}

export interface AnalyzeEntitiesRequest {
  text: string;
}

export interface AnalyzeEntitiesResponse {
  entities: AnalyzeEntitiesResponse_Entity[];
}

export interface AnalyzeEntitiesResponse_Entity {
  text: string;
  type: string;
  score: number;
  start: number;
  end: number;
}

export interface AnalyzeIntentRequest {
  text: string;
}

export interface AnalyzeIntentResponse {
  intent: string;
  confidence: number;
  slots: AnalyzeIntentResponse_Slot[];
}

export interface AnalyzeIntentResponse_Slot {
  text: string;
  type: string;
  score: number;
}

export interface TransformTextRequest {
  text: string;
  model: string;
}

export interface TransformTextResponse {
  text: string;
}

export interface NaturalQueryRequest {
  query: string;
  context: string;
}

export interface NaturalQueryResponse {
  response: string;
  confidence: number;
}

function createBaseClassifyRequest(): ClassifyRequest {
  return { text: [], model: undefined };
}

export const ClassifyRequest = {
  encode(message: ClassifyRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.text) {
      writer.uint32(10).string(v!);
    }
    if (message.model !== undefined) {
      ClassifyRequest_Model.encode(message.model, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClassifyRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClassifyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.model = ClassifyRequest_Model.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClassifyRequest {
    return {
      text: globalThis.Array.isArray(object?.text) ? object.text.map((e: any) => globalThis.String(e)) : [],
      model: isSet(object.model) ? ClassifyRequest_Model.fromJSON(object.model) : undefined,
    };
  },

  toJSON(message: ClassifyRequest): unknown {
    const obj: any = {};
    if (message.text?.length) {
      obj.text = message.text;
    }
    if (message.model !== undefined) {
      obj.model = ClassifyRequest_Model.toJSON(message.model);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClassifyRequest>, I>>(base?: I): ClassifyRequest {
    return ClassifyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClassifyRequest>, I>>(object: I): ClassifyRequest {
    const message = createBaseClassifyRequest();
    message.text = object.text?.map((e) => e) || [];
    message.model = (object.model !== undefined && object.model !== null)
      ? ClassifyRequest_Model.fromPartial(object.model)
      : undefined;
    return message;
  },
};

function createBaseClassifyRequest_Model(): ClassifyRequest_Model {
  return { modelName: "", languageCode: "" };
}

export const ClassifyRequest_Model = {
  encode(message: ClassifyRequest_Model, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.modelName !== "") {
      writer.uint32(10).string(message.modelName);
    }
    if (message.languageCode !== "") {
      writer.uint32(18).string(message.languageCode);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClassifyRequest_Model {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClassifyRequest_Model();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.modelName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.languageCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClassifyRequest_Model {
    return {
      modelName: isSet(object.modelName) ? globalThis.String(object.modelName) : "",
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
    };
  },

  toJSON(message: ClassifyRequest_Model): unknown {
    const obj: any = {};
    if (message.modelName !== "") {
      obj.modelName = message.modelName;
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClassifyRequest_Model>, I>>(base?: I): ClassifyRequest_Model {
    return ClassifyRequest_Model.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClassifyRequest_Model>, I>>(object: I): ClassifyRequest_Model {
    const message = createBaseClassifyRequest_Model();
    message.modelName = object.modelName ?? "";
    message.languageCode = object.languageCode ?? "";
    return message;
  },
};

function createBaseClassifyResponse(): ClassifyResponse {
  return { results: [] };
}

export const ClassifyResponse = {
  encode(message: ClassifyResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.results) {
      ClassifyResponse_Result.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClassifyResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClassifyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.results.push(ClassifyResponse_Result.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClassifyResponse {
    return {
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => ClassifyResponse_Result.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ClassifyResponse): unknown {
    const obj: any = {};
    if (message.results?.length) {
      obj.results = message.results.map((e) => ClassifyResponse_Result.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClassifyResponse>, I>>(base?: I): ClassifyResponse {
    return ClassifyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClassifyResponse>, I>>(object: I): ClassifyResponse {
    const message = createBaseClassifyResponse();
    message.results = object.results?.map((e) => ClassifyResponse_Result.fromPartial(e)) || [];
    return message;
  },
};

function createBaseClassifyResponse_Result(): ClassifyResponse_Result {
  return { label: "", score: 0 };
}

export const ClassifyResponse_Result = {
  encode(message: ClassifyResponse_Result, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.label !== "") {
      writer.uint32(10).string(message.label);
    }
    if (message.score !== 0) {
      writer.uint32(21).float(message.score);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClassifyResponse_Result {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClassifyResponse_Result();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.label = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.score = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClassifyResponse_Result {
    return {
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
    };
  },

  toJSON(message: ClassifyResponse_Result): unknown {
    const obj: any = {};
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.score !== 0) {
      obj.score = message.score;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClassifyResponse_Result>, I>>(base?: I): ClassifyResponse_Result {
    return ClassifyResponse_Result.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClassifyResponse_Result>, I>>(object: I): ClassifyResponse_Result {
    const message = createBaseClassifyResponse_Result();
    message.label = object.label ?? "";
    message.score = object.score ?? 0;
    return message;
  },
};

function createBaseTokenClassifyRequest(): TokenClassifyRequest {
  return { text: [], model: undefined };
}

export const TokenClassifyRequest = {
  encode(message: TokenClassifyRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.text) {
      writer.uint32(10).string(v!);
    }
    if (message.model !== undefined) {
      TokenClassifyRequest_Model.encode(message.model, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TokenClassifyRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenClassifyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.model = TokenClassifyRequest_Model.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenClassifyRequest {
    return {
      text: globalThis.Array.isArray(object?.text) ? object.text.map((e: any) => globalThis.String(e)) : [],
      model: isSet(object.model) ? TokenClassifyRequest_Model.fromJSON(object.model) : undefined,
    };
  },

  toJSON(message: TokenClassifyRequest): unknown {
    const obj: any = {};
    if (message.text?.length) {
      obj.text = message.text;
    }
    if (message.model !== undefined) {
      obj.model = TokenClassifyRequest_Model.toJSON(message.model);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenClassifyRequest>, I>>(base?: I): TokenClassifyRequest {
    return TokenClassifyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenClassifyRequest>, I>>(object: I): TokenClassifyRequest {
    const message = createBaseTokenClassifyRequest();
    message.text = object.text?.map((e) => e) || [];
    message.model = (object.model !== undefined && object.model !== null)
      ? TokenClassifyRequest_Model.fromPartial(object.model)
      : undefined;
    return message;
  },
};

function createBaseTokenClassifyRequest_Model(): TokenClassifyRequest_Model {
  return { modelName: "", languageCode: "" };
}

export const TokenClassifyRequest_Model = {
  encode(message: TokenClassifyRequest_Model, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.modelName !== "") {
      writer.uint32(10).string(message.modelName);
    }
    if (message.languageCode !== "") {
      writer.uint32(18).string(message.languageCode);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TokenClassifyRequest_Model {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenClassifyRequest_Model();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.modelName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.languageCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenClassifyRequest_Model {
    return {
      modelName: isSet(object.modelName) ? globalThis.String(object.modelName) : "",
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
    };
  },

  toJSON(message: TokenClassifyRequest_Model): unknown {
    const obj: any = {};
    if (message.modelName !== "") {
      obj.modelName = message.modelName;
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenClassifyRequest_Model>, I>>(base?: I): TokenClassifyRequest_Model {
    return TokenClassifyRequest_Model.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenClassifyRequest_Model>, I>>(object: I): TokenClassifyRequest_Model {
    const message = createBaseTokenClassifyRequest_Model();
    message.modelName = object.modelName ?? "";
    message.languageCode = object.languageCode ?? "";
    return message;
  },
};

function createBaseTokenClassifyResponse(): TokenClassifyResponse {
  return { results: [] };
}

export const TokenClassifyResponse = {
  encode(message: TokenClassifyResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.results) {
      TokenClassifyResponse_Result.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TokenClassifyResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenClassifyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.results.push(TokenClassifyResponse_Result.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenClassifyResponse {
    return {
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => TokenClassifyResponse_Result.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TokenClassifyResponse): unknown {
    const obj: any = {};
    if (message.results?.length) {
      obj.results = message.results.map((e) => TokenClassifyResponse_Result.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenClassifyResponse>, I>>(base?: I): TokenClassifyResponse {
    return TokenClassifyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenClassifyResponse>, I>>(object: I): TokenClassifyResponse {
    const message = createBaseTokenClassifyResponse();
    message.results = object.results?.map((e) => TokenClassifyResponse_Result.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTokenClassifyResponse_Token(): TokenClassifyResponse_Token {
  return { text: "", label: "", score: 0, start: 0, end: 0 };
}

export const TokenClassifyResponse_Token = {
  encode(message: TokenClassifyResponse_Token, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.label !== "") {
      writer.uint32(18).string(message.label);
    }
    if (message.score !== 0) {
      writer.uint32(29).float(message.score);
    }
    if (message.start !== 0) {
      writer.uint32(32).int32(message.start);
    }
    if (message.end !== 0) {
      writer.uint32(40).int32(message.end);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TokenClassifyResponse_Token {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenClassifyResponse_Token();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.label = reader.string();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.score = reader.float();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.start = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.end = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenClassifyResponse_Token {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      start: isSet(object.start) ? globalThis.Number(object.start) : 0,
      end: isSet(object.end) ? globalThis.Number(object.end) : 0,
    };
  },

  toJSON(message: TokenClassifyResponse_Token): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.score !== 0) {
      obj.score = message.score;
    }
    if (message.start !== 0) {
      obj.start = Math.round(message.start);
    }
    if (message.end !== 0) {
      obj.end = Math.round(message.end);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenClassifyResponse_Token>, I>>(base?: I): TokenClassifyResponse_Token {
    return TokenClassifyResponse_Token.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenClassifyResponse_Token>, I>>(object: I): TokenClassifyResponse_Token {
    const message = createBaseTokenClassifyResponse_Token();
    message.text = object.text ?? "";
    message.label = object.label ?? "";
    message.score = object.score ?? 0;
    message.start = object.start ?? 0;
    message.end = object.end ?? 0;
    return message;
  },
};

function createBaseTokenClassifyResponse_Result(): TokenClassifyResponse_Result {
  return { tokens: [] };
}

export const TokenClassifyResponse_Result = {
  encode(message: TokenClassifyResponse_Result, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.tokens) {
      TokenClassifyResponse_Token.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TokenClassifyResponse_Result {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenClassifyResponse_Result();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tokens.push(TokenClassifyResponse_Token.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenClassifyResponse_Result {
    return {
      tokens: globalThis.Array.isArray(object?.tokens)
        ? object.tokens.map((e: any) => TokenClassifyResponse_Token.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TokenClassifyResponse_Result): unknown {
    const obj: any = {};
    if (message.tokens?.length) {
      obj.tokens = message.tokens.map((e) => TokenClassifyResponse_Token.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenClassifyResponse_Result>, I>>(base?: I): TokenClassifyResponse_Result {
    return TokenClassifyResponse_Result.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenClassifyResponse_Result>, I>>(object: I): TokenClassifyResponse_Result {
    const message = createBaseTokenClassifyResponse_Result();
    message.tokens = object.tokens?.map((e) => TokenClassifyResponse_Token.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAnalyzeEntitiesRequest(): AnalyzeEntitiesRequest {
  return { text: "" };
}

export const AnalyzeEntitiesRequest = {
  encode(message: AnalyzeEntitiesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AnalyzeEntitiesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalyzeEntitiesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalyzeEntitiesRequest {
    return { text: isSet(object.text) ? globalThis.String(object.text) : "" };
  },

  toJSON(message: AnalyzeEntitiesRequest): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AnalyzeEntitiesRequest>, I>>(base?: I): AnalyzeEntitiesRequest {
    return AnalyzeEntitiesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AnalyzeEntitiesRequest>, I>>(object: I): AnalyzeEntitiesRequest {
    const message = createBaseAnalyzeEntitiesRequest();
    message.text = object.text ?? "";
    return message;
  },
};

function createBaseAnalyzeEntitiesResponse(): AnalyzeEntitiesResponse {
  return { entities: [] };
}

export const AnalyzeEntitiesResponse = {
  encode(message: AnalyzeEntitiesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.entities) {
      AnalyzeEntitiesResponse_Entity.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AnalyzeEntitiesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalyzeEntitiesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entities.push(AnalyzeEntitiesResponse_Entity.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalyzeEntitiesResponse {
    return {
      entities: globalThis.Array.isArray(object?.entities)
        ? object.entities.map((e: any) => AnalyzeEntitiesResponse_Entity.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AnalyzeEntitiesResponse): unknown {
    const obj: any = {};
    if (message.entities?.length) {
      obj.entities = message.entities.map((e) => AnalyzeEntitiesResponse_Entity.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AnalyzeEntitiesResponse>, I>>(base?: I): AnalyzeEntitiesResponse {
    return AnalyzeEntitiesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AnalyzeEntitiesResponse>, I>>(object: I): AnalyzeEntitiesResponse {
    const message = createBaseAnalyzeEntitiesResponse();
    message.entities = object.entities?.map((e) => AnalyzeEntitiesResponse_Entity.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAnalyzeEntitiesResponse_Entity(): AnalyzeEntitiesResponse_Entity {
  return { text: "", type: "", score: 0, start: 0, end: 0 };
}

export const AnalyzeEntitiesResponse_Entity = {
  encode(message: AnalyzeEntitiesResponse_Entity, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    if (message.score !== 0) {
      writer.uint32(29).float(message.score);
    }
    if (message.start !== 0) {
      writer.uint32(32).int32(message.start);
    }
    if (message.end !== 0) {
      writer.uint32(40).int32(message.end);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AnalyzeEntitiesResponse_Entity {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalyzeEntitiesResponse_Entity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.score = reader.float();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.start = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.end = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalyzeEntitiesResponse_Entity {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      start: isSet(object.start) ? globalThis.Number(object.start) : 0,
      end: isSet(object.end) ? globalThis.Number(object.end) : 0,
    };
  },

  toJSON(message: AnalyzeEntitiesResponse_Entity): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.score !== 0) {
      obj.score = message.score;
    }
    if (message.start !== 0) {
      obj.start = Math.round(message.start);
    }
    if (message.end !== 0) {
      obj.end = Math.round(message.end);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AnalyzeEntitiesResponse_Entity>, I>>(base?: I): AnalyzeEntitiesResponse_Entity {
    return AnalyzeEntitiesResponse_Entity.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AnalyzeEntitiesResponse_Entity>, I>>(
    object: I,
  ): AnalyzeEntitiesResponse_Entity {
    const message = createBaseAnalyzeEntitiesResponse_Entity();
    message.text = object.text ?? "";
    message.type = object.type ?? "";
    message.score = object.score ?? 0;
    message.start = object.start ?? 0;
    message.end = object.end ?? 0;
    return message;
  },
};

function createBaseAnalyzeIntentRequest(): AnalyzeIntentRequest {
  return { text: "" };
}

export const AnalyzeIntentRequest = {
  encode(message: AnalyzeIntentRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AnalyzeIntentRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalyzeIntentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalyzeIntentRequest {
    return { text: isSet(object.text) ? globalThis.String(object.text) : "" };
  },

  toJSON(message: AnalyzeIntentRequest): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AnalyzeIntentRequest>, I>>(base?: I): AnalyzeIntentRequest {
    return AnalyzeIntentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AnalyzeIntentRequest>, I>>(object: I): AnalyzeIntentRequest {
    const message = createBaseAnalyzeIntentRequest();
    message.text = object.text ?? "";
    return message;
  },
};

function createBaseAnalyzeIntentResponse(): AnalyzeIntentResponse {
  return { intent: "", confidence: 0, slots: [] };
}

export const AnalyzeIntentResponse = {
  encode(message: AnalyzeIntentResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.intent !== "") {
      writer.uint32(10).string(message.intent);
    }
    if (message.confidence !== 0) {
      writer.uint32(21).float(message.confidence);
    }
    for (const v of message.slots) {
      AnalyzeIntentResponse_Slot.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AnalyzeIntentResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalyzeIntentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.intent = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.confidence = reader.float();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.slots.push(AnalyzeIntentResponse_Slot.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalyzeIntentResponse {
    return {
      intent: isSet(object.intent) ? globalThis.String(object.intent) : "",
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
      slots: globalThis.Array.isArray(object?.slots)
        ? object.slots.map((e: any) => AnalyzeIntentResponse_Slot.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AnalyzeIntentResponse): unknown {
    const obj: any = {};
    if (message.intent !== "") {
      obj.intent = message.intent;
    }
    if (message.confidence !== 0) {
      obj.confidence = message.confidence;
    }
    if (message.slots?.length) {
      obj.slots = message.slots.map((e) => AnalyzeIntentResponse_Slot.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AnalyzeIntentResponse>, I>>(base?: I): AnalyzeIntentResponse {
    return AnalyzeIntentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AnalyzeIntentResponse>, I>>(object: I): AnalyzeIntentResponse {
    const message = createBaseAnalyzeIntentResponse();
    message.intent = object.intent ?? "";
    message.confidence = object.confidence ?? 0;
    message.slots = object.slots?.map((e) => AnalyzeIntentResponse_Slot.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAnalyzeIntentResponse_Slot(): AnalyzeIntentResponse_Slot {
  return { text: "", type: "", score: 0 };
}

export const AnalyzeIntentResponse_Slot = {
  encode(message: AnalyzeIntentResponse_Slot, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    if (message.score !== 0) {
      writer.uint32(29).float(message.score);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AnalyzeIntentResponse_Slot {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalyzeIntentResponse_Slot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.score = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalyzeIntentResponse_Slot {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
    };
  },

  toJSON(message: AnalyzeIntentResponse_Slot): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.score !== 0) {
      obj.score = message.score;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AnalyzeIntentResponse_Slot>, I>>(base?: I): AnalyzeIntentResponse_Slot {
    return AnalyzeIntentResponse_Slot.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AnalyzeIntentResponse_Slot>, I>>(object: I): AnalyzeIntentResponse_Slot {
    const message = createBaseAnalyzeIntentResponse_Slot();
    message.text = object.text ?? "";
    message.type = object.type ?? "";
    message.score = object.score ?? 0;
    return message;
  },
};

function createBaseTransformTextRequest(): TransformTextRequest {
  return { text: "", model: "" };
}

export const TransformTextRequest = {
  encode(message: TransformTextRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.model !== "") {
      writer.uint32(18).string(message.model);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransformTextRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransformTextRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.model = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransformTextRequest {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      model: isSet(object.model) ? globalThis.String(object.model) : "",
    };
  },

  toJSON(message: TransformTextRequest): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.model !== "") {
      obj.model = message.model;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransformTextRequest>, I>>(base?: I): TransformTextRequest {
    return TransformTextRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransformTextRequest>, I>>(object: I): TransformTextRequest {
    const message = createBaseTransformTextRequest();
    message.text = object.text ?? "";
    message.model = object.model ?? "";
    return message;
  },
};

function createBaseTransformTextResponse(): TransformTextResponse {
  return { text: "" };
}

export const TransformTextResponse = {
  encode(message: TransformTextResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransformTextResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransformTextResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransformTextResponse {
    return { text: isSet(object.text) ? globalThis.String(object.text) : "" };
  },

  toJSON(message: TransformTextResponse): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransformTextResponse>, I>>(base?: I): TransformTextResponse {
    return TransformTextResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransformTextResponse>, I>>(object: I): TransformTextResponse {
    const message = createBaseTransformTextResponse();
    message.text = object.text ?? "";
    return message;
  },
};

function createBaseNaturalQueryRequest(): NaturalQueryRequest {
  return { query: "", context: "" };
}

export const NaturalQueryRequest = {
  encode(message: NaturalQueryRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.query !== "") {
      writer.uint32(10).string(message.query);
    }
    if (message.context !== "") {
      writer.uint32(18).string(message.context);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NaturalQueryRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNaturalQueryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.query = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.context = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NaturalQueryRequest {
    return {
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      context: isSet(object.context) ? globalThis.String(object.context) : "",
    };
  },

  toJSON(message: NaturalQueryRequest): unknown {
    const obj: any = {};
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.context !== "") {
      obj.context = message.context;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NaturalQueryRequest>, I>>(base?: I): NaturalQueryRequest {
    return NaturalQueryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NaturalQueryRequest>, I>>(object: I): NaturalQueryRequest {
    const message = createBaseNaturalQueryRequest();
    message.query = object.query ?? "";
    message.context = object.context ?? "";
    return message;
  },
};

function createBaseNaturalQueryResponse(): NaturalQueryResponse {
  return { response: "", confidence: 0 };
}

export const NaturalQueryResponse = {
  encode(message: NaturalQueryResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.response !== "") {
      writer.uint32(10).string(message.response);
    }
    if (message.confidence !== 0) {
      writer.uint32(21).float(message.confidence);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NaturalQueryResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNaturalQueryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.response = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.confidence = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NaturalQueryResponse {
    return {
      response: isSet(object.response) ? globalThis.String(object.response) : "",
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
    };
  },

  toJSON(message: NaturalQueryResponse): unknown {
    const obj: any = {};
    if (message.response !== "") {
      obj.response = message.response;
    }
    if (message.confidence !== 0) {
      obj.confidence = message.confidence;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NaturalQueryResponse>, I>>(base?: I): NaturalQueryResponse {
    return NaturalQueryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NaturalQueryResponse>, I>>(object: I): NaturalQueryResponse {
    const message = createBaseNaturalQueryResponse();
    message.response = object.response ?? "";
    message.confidence = object.confidence ?? 0;
    return message;
  },
};

export interface RivaNLPService {
  Classify(request: ClassifyRequest): Promise<ClassifyResponse>;
  TokenClassify(request: TokenClassifyRequest): Promise<TokenClassifyResponse>;
  AnalyzeEntities(request: AnalyzeEntitiesRequest): Promise<AnalyzeEntitiesResponse>;
  AnalyzeIntent(request: AnalyzeIntentRequest): Promise<AnalyzeIntentResponse>;
  TransformText(request: TransformTextRequest): Promise<TransformTextResponse>;
  NaturalQuery(request: NaturalQueryRequest): Promise<NaturalQueryResponse>;
}

export const RivaNLPServiceServiceName = "nvidia.riva.RivaNLPService";
export class RivaNLPServiceClientImpl implements RivaNLPService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || RivaNLPServiceServiceName;
    this.rpc = rpc;
    this.Classify = this.Classify.bind(this);
    this.TokenClassify = this.TokenClassify.bind(this);
    this.AnalyzeEntities = this.AnalyzeEntities.bind(this);
    this.AnalyzeIntent = this.AnalyzeIntent.bind(this);
    this.TransformText = this.TransformText.bind(this);
    this.NaturalQuery = this.NaturalQuery.bind(this);
  }
  Classify(request: ClassifyRequest): Promise<ClassifyResponse> {
    const data = ClassifyRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Classify", data);
    return promise.then((data) => ClassifyResponse.decode(_m0.Reader.create(data)));
  }

  TokenClassify(request: TokenClassifyRequest): Promise<TokenClassifyResponse> {
    const data = TokenClassifyRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "TokenClassify", data);
    return promise.then((data) => TokenClassifyResponse.decode(_m0.Reader.create(data)));
  }

  AnalyzeEntities(request: AnalyzeEntitiesRequest): Promise<AnalyzeEntitiesResponse> {
    const data = AnalyzeEntitiesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AnalyzeEntities", data);
    return promise.then((data) => AnalyzeEntitiesResponse.decode(_m0.Reader.create(data)));
  }

  AnalyzeIntent(request: AnalyzeIntentRequest): Promise<AnalyzeIntentResponse> {
    const data = AnalyzeIntentRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AnalyzeIntent", data);
    return promise.then((data) => AnalyzeIntentResponse.decode(_m0.Reader.create(data)));
  }

  TransformText(request: TransformTextRequest): Promise<TransformTextResponse> {
    const data = TransformTextRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "TransformText", data);
    return promise.then((data) => TransformTextResponse.decode(_m0.Reader.create(data)));
  }

  NaturalQuery(request: NaturalQueryRequest): Promise<NaturalQueryResponse> {
    const data = NaturalQueryRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "NaturalQuery", data);
    return promise.then((data) => NaturalQueryResponse.decode(_m0.Reader.create(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
