// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.29.3
// source: riva_services.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal";
import { Observable } from "rxjs";
import { map } from "rxjs/operators";

export const protobufPackage = "nvidia.riva";

export enum AudioEncoding {
  ENCODING_UNSPECIFIED = 0,
  LINEAR_PCM = 1,
  FLAC = 2,
  MULAW = 3,
  ALAW = 4,
  UNRECOGNIZED = -1,
}

export function audioEncodingFromJSON(object: any): AudioEncoding {
  switch (object) {
    case 0:
    case "ENCODING_UNSPECIFIED":
      return AudioEncoding.ENCODING_UNSPECIFIED;
    case 1:
    case "LINEAR_PCM":
      return AudioEncoding.LINEAR_PCM;
    case 2:
    case "FLAC":
      return AudioEncoding.FLAC;
    case 3:
    case "MULAW":
      return AudioEncoding.MULAW;
    case 4:
    case "ALAW":
      return AudioEncoding.ALAW;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AudioEncoding.UNRECOGNIZED;
  }
}

export function audioEncodingToJSON(object: AudioEncoding): string {
  switch (object) {
    case AudioEncoding.ENCODING_UNSPECIFIED:
      return "ENCODING_UNSPECIFIED";
    case AudioEncoding.LINEAR_PCM:
      return "LINEAR_PCM";
    case AudioEncoding.FLAC:
      return "FLAC";
    case AudioEncoding.MULAW:
      return "MULAW";
    case AudioEncoding.ALAW:
      return "ALAW";
    case AudioEncoding.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Message types for Speech Synthesis */
export interface SynthesizeRequest {
  text: string;
  languageCode: string;
  sampleRateHz: number;
  encoding: AudioEncoding;
  voiceName: string;
  customDictionary?: string | undefined;
}

export interface SynthesizeResponse {
  audio: Uint8Array;
  audioConfig: AudioConfig | undefined;
}

export interface GetRivaSynthesisConfigRequest {
}

export interface GetRivaSynthesisConfigResponse {
  modelConfig: GetRivaSynthesisConfigResponse_ModelConfig[];
}

export interface GetRivaSynthesisConfigResponse_ModelConfig {
  parameters: GetRivaSynthesisConfigResponse_ModelConfig_Parameters | undefined;
}

export interface GetRivaSynthesisConfigResponse_ModelConfig_Parameters {
  languageCode: string;
  voiceName: string;
  subvoices: string;
}

/** Common types */
export interface AudioConfig {
  encoding: AudioEncoding;
  sampleRateHz: number;
  languageCode: string;
  enableWordTimeOffsets: boolean;
  channels: number;
}

function createBaseSynthesizeRequest(): SynthesizeRequest {
  return { text: "", languageCode: "", sampleRateHz: 0, encoding: 0, voiceName: "", customDictionary: undefined };
}

export const SynthesizeRequest = {
  encode(message: SynthesizeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.languageCode !== "") {
      writer.uint32(18).string(message.languageCode);
    }
    if (message.sampleRateHz !== 0) {
      writer.uint32(24).int32(message.sampleRateHz);
    }
    if (message.encoding !== 0) {
      writer.uint32(32).int32(message.encoding);
    }
    if (message.voiceName !== "") {
      writer.uint32(42).string(message.voiceName);
    }
    if (message.customDictionary !== undefined) {
      writer.uint32(50).string(message.customDictionary);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SynthesizeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSynthesizeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.languageCode = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.sampleRateHz = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.encoding = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.voiceName = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.customDictionary = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SynthesizeRequest {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
      sampleRateHz: isSet(object.sampleRateHz) ? globalThis.Number(object.sampleRateHz) : 0,
      encoding: isSet(object.encoding) ? audioEncodingFromJSON(object.encoding) : 0,
      voiceName: isSet(object.voiceName) ? globalThis.String(object.voiceName) : "",
      customDictionary: isSet(object.customDictionary) ? globalThis.String(object.customDictionary) : undefined,
    };
  },

  toJSON(message: SynthesizeRequest): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    if (message.sampleRateHz !== 0) {
      obj.sampleRateHz = Math.round(message.sampleRateHz);
    }
    if (message.encoding !== 0) {
      obj.encoding = audioEncodingToJSON(message.encoding);
    }
    if (message.voiceName !== "") {
      obj.voiceName = message.voiceName;
    }
    if (message.customDictionary !== undefined) {
      obj.customDictionary = message.customDictionary;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SynthesizeRequest>, I>>(base?: I): SynthesizeRequest {
    return SynthesizeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SynthesizeRequest>, I>>(object: I): SynthesizeRequest {
    const message = createBaseSynthesizeRequest();
    message.text = object.text ?? "";
    message.languageCode = object.languageCode ?? "";
    message.sampleRateHz = object.sampleRateHz ?? 0;
    message.encoding = object.encoding ?? 0;
    message.voiceName = object.voiceName ?? "";
    message.customDictionary = object.customDictionary ?? undefined;
    return message;
  },
};

function createBaseSynthesizeResponse(): SynthesizeResponse {
  return { audio: new Uint8Array(0), audioConfig: undefined };
}

export const SynthesizeResponse = {
  encode(message: SynthesizeResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.audio.length !== 0) {
      writer.uint32(10).bytes(message.audio);
    }
    if (message.audioConfig !== undefined) {
      AudioConfig.encode(message.audioConfig, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SynthesizeResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSynthesizeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.audio = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.audioConfig = AudioConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SynthesizeResponse {
    return {
      audio: isSet(object.audio) ? bytesFromBase64(object.audio) : new Uint8Array(0),
      audioConfig: isSet(object.audioConfig) ? AudioConfig.fromJSON(object.audioConfig) : undefined,
    };
  },

  toJSON(message: SynthesizeResponse): unknown {
    const obj: any = {};
    if (message.audio.length !== 0) {
      obj.audio = base64FromBytes(message.audio);
    }
    if (message.audioConfig !== undefined) {
      obj.audioConfig = AudioConfig.toJSON(message.audioConfig);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SynthesizeResponse>, I>>(base?: I): SynthesizeResponse {
    return SynthesizeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SynthesizeResponse>, I>>(object: I): SynthesizeResponse {
    const message = createBaseSynthesizeResponse();
    message.audio = object.audio ?? new Uint8Array(0);
    message.audioConfig = (object.audioConfig !== undefined && object.audioConfig !== null)
      ? AudioConfig.fromPartial(object.audioConfig)
      : undefined;
    return message;
  },
};

function createBaseGetRivaSynthesisConfigRequest(): GetRivaSynthesisConfigRequest {
  return {};
}

export const GetRivaSynthesisConfigRequest = {
  encode(_: GetRivaSynthesisConfigRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetRivaSynthesisConfigRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRivaSynthesisConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetRivaSynthesisConfigRequest {
    return {};
  },

  toJSON(_: GetRivaSynthesisConfigRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetRivaSynthesisConfigRequest>, I>>(base?: I): GetRivaSynthesisConfigRequest {
    return GetRivaSynthesisConfigRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetRivaSynthesisConfigRequest>, I>>(_: I): GetRivaSynthesisConfigRequest {
    const message = createBaseGetRivaSynthesisConfigRequest();
    return message;
  },
};

function createBaseGetRivaSynthesisConfigResponse(): GetRivaSynthesisConfigResponse {
  return { modelConfig: [] };
}

export const GetRivaSynthesisConfigResponse = {
  encode(message: GetRivaSynthesisConfigResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.modelConfig) {
      GetRivaSynthesisConfigResponse_ModelConfig.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetRivaSynthesisConfigResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRivaSynthesisConfigResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.modelConfig.push(GetRivaSynthesisConfigResponse_ModelConfig.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRivaSynthesisConfigResponse {
    return {
      modelConfig: globalThis.Array.isArray(object?.modelConfig)
        ? object.modelConfig.map((e: any) => GetRivaSynthesisConfigResponse_ModelConfig.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetRivaSynthesisConfigResponse): unknown {
    const obj: any = {};
    if (message.modelConfig?.length) {
      obj.modelConfig = message.modelConfig.map((e) => GetRivaSynthesisConfigResponse_ModelConfig.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetRivaSynthesisConfigResponse>, I>>(base?: I): GetRivaSynthesisConfigResponse {
    return GetRivaSynthesisConfigResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetRivaSynthesisConfigResponse>, I>>(
    object: I,
  ): GetRivaSynthesisConfigResponse {
    const message = createBaseGetRivaSynthesisConfigResponse();
    message.modelConfig = object.modelConfig?.map((e) => GetRivaSynthesisConfigResponse_ModelConfig.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseGetRivaSynthesisConfigResponse_ModelConfig(): GetRivaSynthesisConfigResponse_ModelConfig {
  return { parameters: undefined };
}

export const GetRivaSynthesisConfigResponse_ModelConfig = {
  encode(message: GetRivaSynthesisConfigResponse_ModelConfig, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.parameters !== undefined) {
      GetRivaSynthesisConfigResponse_ModelConfig_Parameters.encode(message.parameters, writer.uint32(10).fork())
        .ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetRivaSynthesisConfigResponse_ModelConfig {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRivaSynthesisConfigResponse_ModelConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parameters = GetRivaSynthesisConfigResponse_ModelConfig_Parameters.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRivaSynthesisConfigResponse_ModelConfig {
    return {
      parameters: isSet(object.parameters)
        ? GetRivaSynthesisConfigResponse_ModelConfig_Parameters.fromJSON(object.parameters)
        : undefined,
    };
  },

  toJSON(message: GetRivaSynthesisConfigResponse_ModelConfig): unknown {
    const obj: any = {};
    if (message.parameters !== undefined) {
      obj.parameters = GetRivaSynthesisConfigResponse_ModelConfig_Parameters.toJSON(message.parameters);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetRivaSynthesisConfigResponse_ModelConfig>, I>>(
    base?: I,
  ): GetRivaSynthesisConfigResponse_ModelConfig {
    return GetRivaSynthesisConfigResponse_ModelConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetRivaSynthesisConfigResponse_ModelConfig>, I>>(
    object: I,
  ): GetRivaSynthesisConfigResponse_ModelConfig {
    const message = createBaseGetRivaSynthesisConfigResponse_ModelConfig();
    message.parameters = (object.parameters !== undefined && object.parameters !== null)
      ? GetRivaSynthesisConfigResponse_ModelConfig_Parameters.fromPartial(object.parameters)
      : undefined;
    return message;
  },
};

function createBaseGetRivaSynthesisConfigResponse_ModelConfig_Parameters(): GetRivaSynthesisConfigResponse_ModelConfig_Parameters {
  return { languageCode: "", voiceName: "", subvoices: "" };
}

export const GetRivaSynthesisConfigResponse_ModelConfig_Parameters = {
  encode(
    message: GetRivaSynthesisConfigResponse_ModelConfig_Parameters,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.languageCode !== "") {
      writer.uint32(10).string(message.languageCode);
    }
    if (message.voiceName !== "") {
      writer.uint32(18).string(message.voiceName);
    }
    if (message.subvoices !== "") {
      writer.uint32(26).string(message.subvoices);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetRivaSynthesisConfigResponse_ModelConfig_Parameters {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRivaSynthesisConfigResponse_ModelConfig_Parameters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.languageCode = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.voiceName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.subvoices = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRivaSynthesisConfigResponse_ModelConfig_Parameters {
    return {
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
      voiceName: isSet(object.voiceName) ? globalThis.String(object.voiceName) : "",
      subvoices: isSet(object.subvoices) ? globalThis.String(object.subvoices) : "",
    };
  },

  toJSON(message: GetRivaSynthesisConfigResponse_ModelConfig_Parameters): unknown {
    const obj: any = {};
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    if (message.voiceName !== "") {
      obj.voiceName = message.voiceName;
    }
    if (message.subvoices !== "") {
      obj.subvoices = message.subvoices;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetRivaSynthesisConfigResponse_ModelConfig_Parameters>, I>>(
    base?: I,
  ): GetRivaSynthesisConfigResponse_ModelConfig_Parameters {
    return GetRivaSynthesisConfigResponse_ModelConfig_Parameters.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetRivaSynthesisConfigResponse_ModelConfig_Parameters>, I>>(
    object: I,
  ): GetRivaSynthesisConfigResponse_ModelConfig_Parameters {
    const message = createBaseGetRivaSynthesisConfigResponse_ModelConfig_Parameters();
    message.languageCode = object.languageCode ?? "";
    message.voiceName = object.voiceName ?? "";
    message.subvoices = object.subvoices ?? "";
    return message;
  },
};

function createBaseAudioConfig(): AudioConfig {
  return { encoding: 0, sampleRateHz: 0, languageCode: "", enableWordTimeOffsets: false, channels: 0 };
}

export const AudioConfig = {
  encode(message: AudioConfig, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.encoding !== 0) {
      writer.uint32(8).int32(message.encoding);
    }
    if (message.sampleRateHz !== 0) {
      writer.uint32(16).int32(message.sampleRateHz);
    }
    if (message.languageCode !== "") {
      writer.uint32(26).string(message.languageCode);
    }
    if (message.enableWordTimeOffsets !== false) {
      writer.uint32(32).bool(message.enableWordTimeOffsets);
    }
    if (message.channels !== 0) {
      writer.uint32(40).int32(message.channels);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AudioConfig {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudioConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.encoding = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.sampleRateHz = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.languageCode = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.enableWordTimeOffsets = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.channels = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudioConfig {
    return {
      encoding: isSet(object.encoding) ? audioEncodingFromJSON(object.encoding) : 0,
      sampleRateHz: isSet(object.sampleRateHz) ? globalThis.Number(object.sampleRateHz) : 0,
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
      enableWordTimeOffsets: isSet(object.enableWordTimeOffsets)
        ? globalThis.Boolean(object.enableWordTimeOffsets)
        : false,
      channels: isSet(object.channels) ? globalThis.Number(object.channels) : 0,
    };
  },

  toJSON(message: AudioConfig): unknown {
    const obj: any = {};
    if (message.encoding !== 0) {
      obj.encoding = audioEncodingToJSON(message.encoding);
    }
    if (message.sampleRateHz !== 0) {
      obj.sampleRateHz = Math.round(message.sampleRateHz);
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    if (message.enableWordTimeOffsets !== false) {
      obj.enableWordTimeOffsets = message.enableWordTimeOffsets;
    }
    if (message.channels !== 0) {
      obj.channels = Math.round(message.channels);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AudioConfig>, I>>(base?: I): AudioConfig {
    return AudioConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AudioConfig>, I>>(object: I): AudioConfig {
    const message = createBaseAudioConfig();
    message.encoding = object.encoding ?? 0;
    message.sampleRateHz = object.sampleRateHz ?? 0;
    message.languageCode = object.languageCode ?? "";
    message.enableWordTimeOffsets = object.enableWordTimeOffsets ?? false;
    message.channels = object.channels ?? 0;
    return message;
  },
};

/** Service definitions */
export interface RivaSpeechSynthesis {
  Synthesize(request: SynthesizeRequest): Promise<SynthesizeResponse>;
  SynthesizeOnline(request: SynthesizeRequest): Observable<SynthesizeResponse>;
  GetRivaSynthesisConfig(request: GetRivaSynthesisConfigRequest): Promise<GetRivaSynthesisConfigResponse>;
}

export const RivaSpeechSynthesisServiceName = "nvidia.riva.RivaSpeechSynthesis";
export class RivaSpeechSynthesisClientImpl implements RivaSpeechSynthesis {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || RivaSpeechSynthesisServiceName;
    this.rpc = rpc;
    this.Synthesize = this.Synthesize.bind(this);
    this.SynthesizeOnline = this.SynthesizeOnline.bind(this);
    this.GetRivaSynthesisConfig = this.GetRivaSynthesisConfig.bind(this);
  }
  Synthesize(request: SynthesizeRequest): Promise<SynthesizeResponse> {
    const data = SynthesizeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Synthesize", data);
    return promise.then((data) => SynthesizeResponse.decode(_m0.Reader.create(data)));
  }

  SynthesizeOnline(request: SynthesizeRequest): Observable<SynthesizeResponse> {
    const data = SynthesizeRequest.encode(request).finish();
    const result = this.rpc.serverStreamingRequest(this.service, "SynthesizeOnline", data);
    return result.pipe(map((data) => SynthesizeResponse.decode(_m0.Reader.create(data))));
  }

  GetRivaSynthesisConfig(request: GetRivaSynthesisConfigRequest): Promise<GetRivaSynthesisConfigResponse> {
    const data = GetRivaSynthesisConfigRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetRivaSynthesisConfig", data);
    return promise.then((data) => GetRivaSynthesisConfigResponse.decode(_m0.Reader.create(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
  clientStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Promise<Uint8Array>;
  serverStreamingRequest(service: string, method: string, data: Uint8Array): Observable<Uint8Array>;
  bidirectionalStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Observable<Uint8Array>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
